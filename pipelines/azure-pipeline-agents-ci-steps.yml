# This pipeline is for CI/CD
parameters:
- name: clear
  displayName: Clear State
  type: boolean
  default: false
- name: deploy
  displayName: Deploy Agent Infrastructure
  type: boolean
  default: true
- name: destroy
  displayName: Destroy Infrastructure
  type: string
  default: Always
  values:
  - Always
  - Never 
  - 'On failure'
  - 'On success'
- name: retryCount
  displayName: Terraform task retry count
  type: number
  default: 1
- name: testReentrance
  displayName: Test Terraform re-entrance (apply twice)
  type: boolean
  default: true
- name: unpinTerraform
  displayName: Unpin Terraform version
  type: boolean
  default: false
- name: unpinTerraformProviders
  displayName: Unpin Terraform provider versions
  type: boolean
  default: false

steps:
  - checkout: self
    submodules: true

  - ${{ if not(parameters.unpinTerraform) }}:
    - pwsh: |
        $terraformVersion = (Get-Content .terraform-version)
        Write-Host "##vso[task.setvariable variable=version;isOutput=true]${terraformVersion}"
        Copy-Item backend.tf.sample backend.tf
      name: terraformConfig
      displayName: 'Prepare Terraform config (pinned)'
      workingDirectory: '$(terraformDirectory)'
  - ${{ if parameters.unpinTerraform }}:
    - pwsh: |
        (Get-Content ./provider.tf) -replace "required_version *= `" *(~>|=) +",'required_version = ">= ' | Out-File provider.tf
        Get-Content ./provider.tf
        Write-Host "##vso[task.setvariable variable=version;isOutput=true]latest"
        Copy-Item backend.tf.sample backend.tf
      name: terraformConfig
      displayName: 'Prepare Terraform config (unpinned/latest)'
      workingDirectory: '$(terraformDirectory)'

  - task: TerraformInstaller@0
    displayName: 'Install Terraform'
    inputs:
      terraformVersion: '$(terraformConfig.version)'

  - ${{ if parameters.unpinTerraformProviders }}:
    # Unpin version e.g. "= 2.56" -> "~> 2.56"
    - pwsh: |
        (Get-Content ./provider.tf) -replace " = `" *= +",' = "~> ' | Out-File provider.tf
        Get-Content ./provider.tf
        if (Test-Path .terraform.lock.hcl) {
          Remove-Item .terraform.lock.hcl -Force
        }
      displayName: 'Unpin Terraform provider versions'
      # condition required as '- ${{ if ' template expression is not evaluated when using a strategy
      condition: and(succeeded(), eq(variables['unpinTerraformProviders'],'true'))
      workingDirectory: '$(terraformDirectory)'

  - task: AzureCLI@2
    displayName: 'Terraform init'
    inputs:
      azureSubscription: '$(subscriptionConnection)'
      scriptType: pscore
      scriptLocation: inlineScript
      inlineScript: |
        $(identityScriptDirectory)/set_terraform_azurerm_vars.ps1
        ./deploy.ps1 -Init
      addSpnToEnvironment: true
      useGlobalConfig: true
      failOnStandardError: true
      workingDirectory: '$(scriptDirectory)'

  - publish: $(terraformDirectory)
    displayName: 'Publish Terraform workspace'
    artifact: $(terraformArtifactPrefix)$(System.PlanId)

  - ${{ if eq(parameters.clear, true) }}:
    - task: AzureCLI@2
      name: clear
      displayName: 'Clear Terraform state'
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        scriptType: pscore
        scriptLocation: inlineScript
        inlineScript: |
          $(identityScriptDirectory)/set_terraform_azurerm_vars.ps1

          $terraformState = (terraform state pull | ConvertFrom-Json)
          if ($terraformState.resources) {
            Write-Host "Clearing Terraform state in workspace ${env:TF_WORKSPACE}..."
            $terraformState.outputs = New-Object PSObject # Empty output
            $terraformState.resources = @() # No resources
            $terraformState.serial++
            $terraformState | ConvertTo-Json | terraform state push -
          } else {
            Write-Host "No resources in Terraform state in workspace ${env:TF_WORKSPACE}..."
          }
          terraform state pull 
        addSpnToEnvironment: true
        useGlobalConfig: true
        failOnStandardError: true
        workingDirectory: '$(terraformDirectory)'

  - ${{ if not(parameters.clear) }}:
    - task: AzureCLI@2
      displayName: 'Restore SSH key pair'
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        scriptType: pscore
        scriptLocation: inlineScript
        inlineScript: |
          $(identityScriptDirectory)/set_terraform_azurerm_vars.ps1
          ./get_ssh_key_pair.ps1 -Keyname $(TF_VAR_ssh_private_key) -Force
          $keyDirectory = (Split-Path $(TF_VAR_ssh_private_key) -Parent)
          if (Test-Path $keyDirectory) {
            ls -al $keyDirectory
          }
        addSpnToEnvironment: true
        useGlobalConfig: true
        failOnStandardError: true
        workingDirectory: '$(scriptDirectory)'

  - bash: |
      if [ -f "$(TF_VAR_ssh_private_key)" ]; then
          echo "$(TF_VAR_ssh_private_key) already exists, skipping key pair generation"
      else 
          echo "$(TF_VAR_ssh_private_key) does not exist, generation key pair..."
          mkdir -p $(dirname $(TF_VAR_ssh_private_key))
          ssh-keygen -q -m PEM -N '' -f $(TF_VAR_ssh_private_key)
      fi
      ls -al $(dirname $(TF_VAR_ssh_private_key))
    displayName: 'Generate SSH key pair'
    workingDirectory: '$(terraformDirectory)'

  - task: AzureCLI@2
    name: terraformVariables
    displayName: 'Prepare Terraform variables'
    inputs:
      azureSubscription: '$(subscriptionConnection)'
      scriptType: pscore
      scriptLocation: inlineScript
      inlineScript: |
        $(identityScriptDirectory)/set_terraform_azurerm_vars.ps1

        if ($${{ not(parameters.clear) }} -and (!((terraform output resource_suffix 2>&1) -match "Warning"))) {
          $env:TF_VAR_RESOURCE_SUFFIX = $null
          $env:TF_VAR_resource_suffix = "$(terraform output -raw resource_suffix 2>$null)"
        }

        # Re-use service connection
        Get-ChildItem -Path Env: -Recurse -Include ENDPOINT_DATA_* | Select-Object -First 1 -ExpandProperty Name `
                                                                    | ForEach-Object { $_.Split("_")[2] }
                                                                    | Set-Item env:TF_VAR_azdo_service_connection_id

        # Parse alternate strategy variables
        if ($$(substituteAlternateVariables)) {
          foreach ($alternateVar in $(Get-ChildItem -Path Env: -Recurse -Include ALTERNATE_TF_VAR_*)) {
            $primaryTerraformVariableName = $alternateVar.Name.Substring(17).ToLowerInvariant()
            $primaryVariableName = "TF_VAR_${primaryTerraformVariableName}"
            $variableValue = $alternateVar.Value

            # Replace primary value with alternate
            Get-ChildItem -path env: -Recurse -Include $primaryVariableName | Remove-Item
            Set-Item env:${primaryVariableName} -Value $variableValue
          } 
        }

        # List environment variables
        Get-ChildItem -Path Env: -Recurse -Include ALTERNATE_*,ARM_*,AZURE_*,PIPELINE_DEMO_*,SYSTEM_*,TF_* | Sort-Object -Property Name

        # Convert uppercased Terraform environment variables to .auto.tfvars file
        foreach ($tfvar in $(Get-ChildItem -Path Env: -Recurse -Include TF_VAR_*)) {
          $terraformVariableName = $tfvar.Name.Substring(7).ToLowerInvariant()
          $terraformVariableValue = $tfVar.Value

          if ($terraformVariableValue -imatch "^\W*(true|false|\[[^\]]*\]|\{[^\}]*\})\W*$") {
            # Boolean or List, write as-is
            Write-Output "${terraformVariableName} = ${terraformVariableValue}" | Out-File ci.auto.tfvars -Append -Force
          } else {
            Write-Output "${terraformVariableName} = `"${terraformVariableValue}`"" | Out-File ci.auto.tfvars -Append -Force
          }
        } 
        Write-Host "Contents of ci.auto.tfvars:"
        Get-Content ci.auto.tfvars | Sort-Object        
      addSpnToEnvironment: true
      useGlobalConfig: true
      failOnStandardError: true
      workingDirectory: '$(terraformDirectory)'

  - ${{ if parameters.deploy }}:
    - task: AzureCLI@2
      displayName: 'Disable Self-Hosted Agent(s)'
      name: 'agentConfig'
      condition: and(eq(variables['TF_VAR_deploy_self_hosted_vms'],'true'),succeeded())
      continueOnError: false
      inputs:
        azureSubscription: '$(azdoConnection)'
        scriptType: 'pscore'
        scriptLocation: 'inlineScript'
        inlineScript: |
          if ((${env:system.debug} -eq "true") -or ($env:system_debug -eq "true") -or ($env:SYSTEM_DEBUG -eq "true")) {
            $DebugPreference       = "Continue"
            $InformationPreference = "Continue"
            $VerbosePreference     = "Continue"
          }
          ./update_agent_status.ps1 -Enabled:$false `
                                    -AgentPoolName $(TF_VAR_azdo_linux_pipeline_agent_pool) `
                                    -AgentNamePrefix "$(TF_VAR_azure_linux_pipeline_agent_name_prefix)-$(TF_WORKSPACE)-"
          ./update_agent_status.ps1 -Enabled:$false `
                                    -AgentPoolName $(TF_VAR_azdo_windows_pipeline_agent_pool) `
                                    -AgentNamePrefix "$(TF_VAR_azure_windows_pipeline_agent_name_prefix)-$(TF_WORKSPACE)-"
        addSpnToEnvironment: true
        useGlobalConfig: true
        workingDirectory: '$(scriptDirectory)'

  - ${{ if parameters.deploy }}:
    - task: AzureCLI@2
      displayName: 'Terraform plan & apply (deploy_firewall:$(TF_VAR_deploy_firewall))'
      name: apply
      retryCountOnTaskFailure: ${{ parameters.retryCount }}
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        scriptType: pscore
        scriptLocation: inlineScript
        inlineScript: |
          $(identityScriptDirectory)/set_terraform_azurerm_vars.ps1
          ./deploy.ps1 -apply -force
        addSpnToEnvironment: true
        useGlobalConfig: true
        failOnStandardError: true
        workingDirectory: '$(scriptDirectory)'

  - ${{ if parameters.deploy }}:
    - task: AzureCLI@2
      displayName: 'Enable Self-Hosted Agent(s)'
      condition: and(eq(variables['TF_VAR_deploy_self_hosted_vms'],'true'),succeeded())
      inputs:
        azureSubscription: '$(azdoConnection)'
        scriptType: 'pscore'
        scriptLocation: 'inlineScript'
        inlineScript: |
          if ((${env:system.debug} -eq "true") -or ($env:system_debug -eq "true") -or ($env:SYSTEM_DEBUG -eq "true")) {
            $DebugPreference       = "Continue"
            $InformationPreference = "Continue"
            $VerbosePreference     = "Continue"
          }
          ./update_agent_status.ps1 -Enabled:$true `
                                    -AgentPoolName $(TF_VAR_azdo_linux_pipeline_agent_pool) `
                                    -AgentNamePrefix "$(TF_VAR_azure_linux_pipeline_agent_name_prefix)-$(TF_WORKSPACE)-"
          ./update_agent_status.ps1 -Enabled:$true `
                                    -AgentPoolName $(TF_VAR_azdo_windows_pipeline_agent_pool) `
                                    -AgentNamePrefix "$(TF_VAR_azure_windows_pipeline_agent_name_prefix)-$(TF_WORKSPACE)-"

        addSpnToEnvironment: true
        useGlobalConfig: true
        workingDirectory: '$(scriptDirectory)'      

  - ${{ if and(parameters.deploy,parameters.testReentrance) }}:
    - task: AzureCLI@2
      displayName: 'Terraform plan & apply (re-entrance test)'
      retryCountOnTaskFailure: ${{ parameters.retryCount }}
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        scriptType: pscore
        scriptLocation: inlineScript
        inlineScript: |
          $(identityScriptDirectory)/set_terraform_azurerm_vars.ps1

          # Swap NAT Gateway <-> Azure Firewall
          # $env:TF_VAR_deploy_firewall = ($env:TF_VAR_deploy_firewall -ieq "true" ? "false" : "true")
          ./deploy.ps1 -apply -force
        addSpnToEnvironment: true
        useGlobalConfig: true
        failOnStandardError: true
        workingDirectory: '$(scriptDirectory)'
        
  - ${{ if not(eq(parameters.destroy, 'Never')) }}:
    - pwsh: |
        Write-Host "##vso[task.setvariable variable=result;isOutput=true]success"
      name: provisioningResult
      displayName: 'Indicate provisioning success'
      condition: succeeded()

  - ${{ if not(eq(parameters.destroy, 'Never')) }}:
    - task: AzureCLI@2
      displayName: 'Terraform destroy (${{ lower(parameters.destroy) }})'
      ${{ if eq(parameters.destroy, 'Always') }}:
        condition: succeededOrFailed()
      ${{ if eq(parameters.destroy, 'On failure') }}:
        condition: failed()
      ${{ if eq(parameters.destroy, 'On success') }}:
        condition: succeeded()
      continueOnError: true # Treat failure as warning during destroy, we will clean up anyway
      retryCountOnTaskFailure: ${{ parameters.retryCount }}
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        scriptType: pscore
        scriptLocation: inlineScript
        inlineScript: |
          $(identityScriptDirectory)/set_terraform_azurerm_vars.ps1
          ./deploy.ps1 -destroy -force
        addSpnToEnvironment: true
        useGlobalConfig: true
        failOnStandardError: true
        workingDirectory: '$(scriptDirectory)'

  - ${{ if ne(parameters.destroy, 'Never') }}:
    - task: AzureCLI@2
      name: teardown
      displayName: 'Tear down remaining resources'
      ${{ if eq(parameters.destroy, 'Always') }}:
        condition: or(always(),canceled())
      ${{ if eq(parameters.destroy, 'On failure') }}:
        condition: not(eq(variables['provisioningResult.result'],'success'))
      ${{ if eq(parameters.destroy, 'On success') }}:
        condition: eq(variables['provisioningResult.result'],'success')
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        scriptType: pscore
        scriptLocation: inlineScript
        inlineScript: |
          $ErrorActionPreference = "Continue" # Continue to remove resources if remove by resource group fails
          # Build JMESPath expression
          $tagQuery = "[?tags.repository == '$(repository)' && tags.workspace == '$(TF_WORKSPACE)' && tags.runid == '$(Build.BuildId)' && properties.provisioningState != 'Deleting'].id"
          Write-Host "Removing resources identified by `"$tagQuery`"..."

          # Remove resource groups
          $resourceGroupIDs = $(az group list --query "${tagQuery}" -o tsv)
          if ($resourceGroupIDs) {
            Write-Host "Removing resource group(s) `"${resourceGroupIDs}`"..."
            &{ # az writes information to stderr
              $ErrorActionPreference = 'SilentlyContinue'
              az resource delete --ids $resourceGroupIDs 2>&1
            }
          } else {
            Write-Host "No resource groups to remove"
          }

          # Remove (remaining) resources
          $resourceIDs = $(az resource list --query "${tagQuery}" -o tsv)
          if ($resourceIDs) {
            Write-Host "Removing resources `"${resourceIDs}`"..."
            &{ # az writes information to stderr
              $ErrorActionPreference = 'SilentlyContinue'
              az resource delete --ids $resourceIDs 2>&1
            }
          } else {
            Write-Host "No resources to remove"
          }

          # Remove policy definition
          ./delete_policy.ps1 -Workspace $(TF_WORKSPACE)
        addSpnToEnvironment: true
        useGlobalConfig: true
        failOnStandardError: true
        workingDirectory: '$(scriptDirectory)'

  - ${{ if ne(parameters.destroy, 'Never') }}:
    - task: AzureCLI@2
      name: cleanup
      displayName: 'Clean up Terraform state'
      ${{ if eq(parameters.destroy, 'Always') }}:
        condition: or(always(),canceled())
      ${{ if eq(parameters.destroy, 'On failure') }}:
        condition: not(eq(variables['provisioningResult.result'],'success'))
      ${{ if eq(parameters.destroy, 'On success') }}:
        condition: eq(variables['provisioningResult.result'],'success')
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        scriptType: pscore
        scriptLocation: inlineScript
        inlineScript: |
          $(identityScriptDirectory)/set_terraform_azurerm_vars.ps1

          $terraformState = (terraform state pull | ConvertFrom-Json)
          if ($terraformState.resources) {
            Write-Host "Clearing Terraform state in workspace ${env:TF_WORKSPACE}..."
            $terraformState.outputs = New-Object PSObject # Empty output
            $terraformState.resources = @() # No resources
            $terraformState.serial++
            $terraformState | ConvertTo-Json | terraform state push -
          } else {
            Write-Host "No resources in Terraform state in workspace ${env:TF_WORKSPACE}..."
          }
          terraform state pull 
        addSpnToEnvironment: true
        useGlobalConfig: true
        failOnStandardError: true
        workingDirectory: '$(terraformDirectory)'