# This pipeline is for CI/CD
parameters:
- name: workspace
  displayName: Pipeline Environment / Terraform Workspace prefix
  type: string
  default: ci
  values:
  - ci
  - ci1
  - ci2
  - ci3
  - cd1
  - cd2
  - cd3
- name: clear
  displayName: Clear State
  type: boolean
  default: false
- name: egressDevice
  displayName: Egress device
  type: string
  default: 'NAT Gateway'
  values:
  - Firewall
  - 'NAT Gateway'
  - Strategy
- name: deploy
  displayName: Deploy Agents
  type: boolean
  default: true
- name: destroy
  displayName: Destroy Infrastructure
  type: string
  default: Always
  values:
  - Always
  - Never 
  - 'On failure'
  - 'On success'
- name: testReentrance
  displayName: Test Terraform re-entrance (apply twice)
  type: boolean
  default: true
- name: unpinTerraform
  displayName: Unpin Terraform version
  type: boolean
  default: false
- name: unpinTerraformProviders
  displayName: Unpin Terraform provider versions
  type: string
  default: No
  values:
  - No
  - Yes
  - Strategy

name: $(Date:yyyyMMdd)$(Rev:.r)-$(Build.DefinitionVersion)-$(SourceBranchName)-${{ parameters.workspace }}-$(Build.BuildId)

trigger: none

pr:
  autoCancel: false
  branches:
    include:
    - '*'
  drafts: false
  paths:
    exclude:
    - '.devcontainer/**'  
    - 'visuals/**'  
    - '*.md'  

schedules:
- cron: '0 0 * * Mon,Wed,Fri'
  displayName: 'Bi-Nightly build (UTC)'
  # Run if there are no changes
  always: 'true'
  branches:
    include:
    - master

variables:
- group: 'pipeline-agents-ci'
- name: 'jobTimeOutMinutes'
  value: 180
- name: 'repository'
  value: 'azure-pipeline-agents'
- name: AZURE_CORE_ONLY_SHOW_ERRORS
  value: 'true'
- name: AZURE_EXTENSION_USE_DYNAMIC_INSTALL
  value: 'yes_without_prompt'
- name: 'substituteAlternateVariables'
  value: 'false'
- name: 'TF_IN_AUTOMATION'
  value: 'true'
- name: 'TF_INPUT'
  value: 0
- name: 'scriptDirectory'
  value: '$(Build.SourcesDirectory)/scripts'
- name: 'terraformDirectory'
  value: '$(Build.SourcesDirectory)/terraform'
- name: 'TF_VAR_linux_pipeline_agent_name_prefix'
  value: 'ubuntu-agent'
- name: 'TF_VAR_run_id'
  value: '$(Build.BuildId)'
- name: 'TF_VAR_ssh_public_key'
  value: 'id_rsa.pub' # Key will be downloaded in terraform directory
- name: 'TF_VAR_windows_pipeline_agent_name_prefix'
  value: 'windows-agent'

- name: 'resourceGroup' 
  value: 'azure-pipelines-agents-$(TF_WORKSPACE)-$(TF_VAR_resource_suffix)'

jobs:
- job: 'Provision'
  ${{ if and(eq(parameters.destroy, 'Always'),parameters.deploy) }}:
    displayName: 'Provision, Deploy, Test & Destroy'
  ${{ if and(eq(parameters.destroy, 'Never'),parameters.deploy) }}:
    displayName: 'Provision, Deploy & Test'
  ${{ if and(eq(parameters.destroy, 'On failure'),parameters.deploy) }}:
    displayName: 'Provision, Deploy, Test & Destroy (${{ lower(parameters.destroy) }})'
  ${{ if and(eq(parameters.destroy, 'On success'),parameters.deploy) }}:
    displayName: 'Provision, Deploy, Test & Destroy (${{ lower(parameters.destroy) }})'
  ${{ if and(eq(parameters.destroy, 'Always'),not(parameters.deploy)) }}:
    displayName: 'Provision & Destroy'
  ${{ if and(eq(parameters.destroy, 'Never'),not(parameters.deploy)) }}:
    displayName: 'Provision'
  ${{ if and(eq(parameters.destroy, 'On failure'),not(parameters.deploy)) }}:
    displayName: 'Provision & Destroy (${{ lower(parameters.destroy) }})'
  ${{ if and(eq(parameters.destroy, 'On success'),not(parameters.deploy)) }}:
    displayName: 'Provision & Destroy (${{ lower(parameters.destroy) }})'
  condition: succeeded()
  timeoutInMinutes: $[ variables['jobTimeOutMinutes'] ]

  pool:
    name: '$(pool)'
    vmImage: $(vmImage)

  ${{ if or(eq(parameters.unpinTerraformProviders, 'Strategy'),eq(parameters.egressDevice, 'Strategy'),ne(variables['Build.Reason'], 'Manual')) }}:
    strategy:
      matrix:
        primary:
          resourceGroup: '$(TF_VAR_resource_prefix)-${{ parameters.workspace }}a-$(Build.BuildId)'
          terraformArtifactName: 'terraformPrimary'
          substituteAlternateVariables: false
          TF_VAR_resource_suffix: '$(Build.BuildId)'
          TF_VAR_deploy_firewall: ${{ lower(eq(parameters.egressDevice, 'Firewall')) }}
          TF_WORKSPACE: '${{ parameters.workspace }}a'
          unpinTerraformProviders: ${{ lower(eq(parameters.unpinTerraformProviders, 'Yes')) }}
        alternate:
          resourceGroup: '$(TF_VAR_resource_prefix)-${{ parameters.workspace }}b-$(Build.BuildId)'
          terraformArtifactName: 'terraformAlternate'
          substituteAlternateVariables: true
          TF_VAR_resource_suffix: '$(Build.BuildId)b'
          TF_VAR_deploy_firewall: ${{ lower(or(eq(parameters.egressDevice, 'Firewall'),eq(parameters.egressDevice, 'Strategy'),ne(variables['Build.Reason'], 'Manual'))) }}
          TF_WORKSPACE: '${{ parameters.workspace }}a'
          unpinTerraformProviders: ${{ lower(or(eq(parameters.unpinTerraformProviders, 'Yes'),eq(parameters.unpinTerraformProviders, 'Strategy'),ne(variables['Build.Reason'], 'Manual'))) }}
      maxParallel: 2

  variables:
    ${{ if not(or(eq(parameters.unpinTerraformProviders, 'Strategy'),eq(parameters.egressDevice, 'Strategy'),ne(variables['Build.Reason'], 'Manual'))) }}:
      # Not running as strategy
      terraformArtifactName: 'terraformPrimary'
      ${{ if parameters.clear }}:  # Don't reset suffix if we want to keep existing resources
        TF_VAR_resource_suffix: '$(Build.BuildId)'
      TF_WORKSPACE: '${{ parameters.workspace }}'
      unpinTerraformProviders: ${{ lower(eq(parameters.unpinTerraformProviders, 'Yes')) }}
      resourceGroup: '$(TF_VAR_resource_prefix)-${{ parameters.workspace }}-$(Build.BuildId)'

  workspace:
    clean: all

  steps:
    - task: DownloadSecureFile@1
      displayName: 'Download SSH Public Key'
      inputs:
        secureFile: '$(TF_VAR_ssh_public_key)'
    - pwsh: |
        foreach ($file in $(Get-ChildItem Env:*SECUREFILEPATH))
        {
            Copy-Item $file.Value '$(terraformDirectory)'
        }
      displayName: 'Copy Secure Files'

    - ${{ if not(parameters.unpinTerraform) }}:
      - pwsh: |
          $terraformVersion = (Get-Content .terraform-version)
          Write-Host "##vso[task.setvariable variable=version;isOutput=true]${terraformVersion}"
          Copy-Item backend.tf.sample backend.tf
        name: terraformConfig
        displayName: 'Prepare Terraform config (pinned)'
        workingDirectory: '$(terraformDirectory)'
    - ${{ if parameters.unpinTerraform }}:
      - pwsh: |
          (Get-Content ./provider.tf) -replace "required_version *= `" *(~>|=) +",'required_version = ">= ' | Out-File provider.tf
          Get-Content ./provider.tf
          Write-Host "##vso[task.setvariable variable=version;isOutput=true]latest"
          Copy-Item backend.tf.sample backend.tf
        name: terraformConfig
        displayName: 'Prepare Terraform config (unpinned/latest)'
        workingDirectory: '$(terraformDirectory)'

    - task: TerraformInstaller@0
      displayName: 'Install Terraform'
      inputs:
        terraformVersion: '$(terraformConfig.version)'

    - ${{ if or(eq(parameters.unpinTerraformProviders, 'Yes'),eq(parameters.unpinTerraformProviders, 'Strategy'),not(eq(variables['Build.Reason'], 'Manual'))) }}:
      # Unpin version e.g. "= 2.56" -> "~> 2.56"
      - pwsh: |
          (Get-Content ./provider.tf) -replace " = `" *= +",' = "~> ' | Out-File provider.tf
          Get-Content ./provider.tf
          if (Test-Path .terraform.lock.hcl) {
            Remove-Item .terraform.lock.hcl -Force
          }
        displayName: 'Unpin Terraform provider versions'
        # condition required as '- ${{ if ' template expression is not evaluated when using a strategy
        condition: and(succeeded(), eq(variables['unpinTerraformProviders'],'true'))
        workingDirectory: '$(terraformDirectory)'

    - task: TerraformCLI@0
      displayName: 'Terraform init'
      inputs:
        command: 'init'
        workingDirectory: '$(terraformDirectory)'
        backendType: 'azurerm'
        backendServiceArm: '$(subscriptionConnection)'
        backendAzureRmResourceGroupName: '$(TF_STATE_RESOURCE_GROUP_NAME)'
        backendAzureRmStorageAccountName: '$(TF_STATE_STORAGE_ACCOUNT_NAME)'
        backendAzureRmContainerName: '$(TF_STATE_CONTAINER_NAME)'
        backendAzureRmKey: 'terraform.tfstate'
        allowTelemetryCollection: true

    - publish: $(terraformDirectory)
      displayName: 'Publish Terraform workspace'
      artifact: $(terraformArtifactName)

    - ${{ if eq(parameters.clear, true) }}:
      - task: AzureCLI@2
        name: cleanup
        displayName: 'Clear Terraform state'
        inputs:
          azureSubscription: '$(subscriptionConnection)'
          scriptType: pscore
          scriptLocation: inlineScript
          inlineScript: |
            $(scriptDirectory)/set_terraform_azurerm_vars.ps1

            $terraformState = (terraform state pull | ConvertFrom-Json)
            if ($terraformState.resources) {
              Write-Host "Clearing Terraform state in workspace ${env:TF_WORKSPACE}..."
              $terraformState.outputs = New-Object PSObject # Empty output
              $terraformState.resources = @() # No resources
              $terraformState.serial++
              $terraformState | ConvertTo-Json | terraform state push -
            } else {
              Write-Host "No resources in Terraform state in workspace ${env:TF_WORKSPACE}..."
            }
            terraform state pull 
          addSpnToEnvironment: true
          useGlobalConfig: true
          failOnStandardError: true
          workingDirectory: '$(terraformDirectory)'

    - task: AzureCLI@2
      name: avoidVMImages
      displayName: 'Avoid VM image versions with known issues'
      condition: startsWith(coalesce(variables['TF_VAR_windows_os_version'],'vs-2022-comm-latest-win11-n'), 'vs-2022-comm')
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        scriptType: pscore
        scriptLocation: inlineScript
        inlineScript: |
          az vm image list -l $(TF_VAR_location) -s "vs-2022-comm-latest-ws2022" -f "visualstudio2022" -p "microsoftvisualstudio" --query "max_by([?version!='2021.12.16' && version!='2022.01.14'],&version).version" --all -o tsv | Set-Item env:TF_VAR_windows_os_version
          Write-Output "windows_os_version = `"${env:TF_VAR_windows_os_version}`""
          Write-Output "windows_os_version = `"${env:TF_VAR_windows_os_version}`"" | Out-File ci.auto.tfvars -Append -Force
        useGlobalConfig: true
        failOnStandardError: true
        workingDirectory: '$(terraformDirectory)'

    - pwsh: |
        if ($${{ not(parameters.clear) }} -and (!((terraform output resource_suffix 2>&1) -match "Warning"))) {
          $env:TF_VAR_RESOURCE_SUFFIX = $null
          $env:TF_VAR_resource_suffix = "$(terraform output -raw resource_suffix 2>$null)"
        }

        # Parse alternate strategy variables
        if ($$(substituteAlternateVariables)) {
          foreach ($alternateVar in $(Get-ChildItem -Path Env: -Recurse -Include ALTERNATE_TF_VAR_*)) {
            $primaryTerraformVariableName = $alternateVar.Name.Substring(17).ToLowerInvariant()
            $primaryVariableName = "TF_VAR_${primaryTerraformVariableName}"
            $variableValue = $alternateVar.Value

            # Replace primary value with alternate
            Get-ChildItem -path env: -Recurse -Include $primaryVariableName | Remove-Item
            Set-Item env:${primaryVariableName} -Value $variableValue
          } 
        }

        # List environment variables
        Get-ChildItem -Path Env: -Recurse -Include ALTERNATE_*,ARM_*,AZURE_*,PIPELINE_DEMO_*,SYSTEM_*,TF_* | Sort-Object -Property Name

        # Convert uppercased Terraform environment variables to .auto.tfvars file
        foreach ($tfvar in $(Get-ChildItem -Path Env: -Recurse -Include TF_VAR_*)) {
          $terraformVariableName = $tfvar.Name.Substring(7).ToLowerInvariant()
          $terraformVariableValue = $tfVar.Value

          if ($terraformVariableValue -imatch "^\W*(true|false|\[[^\]]*\]|\{[^\}]*\})\W*$") {
            # Boolean or List, write as-is
            Write-Output "${terraformVariableName} = ${terraformVariableValue}" | Out-File ci.auto.tfvars -Append -Force
          } else {
            Write-Output "${terraformVariableName} = `"${terraformVariableValue}`"" | Out-File ci.auto.tfvars -Append -Force
          }
        } 
        Write-Host "Contents of ci.auto.tfvars:"
        Get-Content ci.auto.tfvars
      name: terraformVariables
      displayName: 'Prepare Terraform variables'
      workingDirectory: '$(terraformDirectory)'

    - ${{ if parameters.deploy }}:
      - task: AzureCLI@2
        displayName: 'Disable Self-Hosted Agent(s)'
        name: 'agentConfig'
        condition: and(eq(variables['TF_VAR_deploy_self_hosted_vms'],'true'),succeeded())
        continueOnError: false
        inputs:
          azureSubscription: '$(subscriptionConnection)'
          scriptType: 'pscore'
          scriptLocation: 'inlineScript'
          inlineScript: |
            if ((${env:system.debug} -eq "true") -or ($env:system_debug -eq "true") -or ($env:SYSTEM_DEBUG -eq "true")) {
              $DebugPreference       = "Continue"
              $InformationPreference = "Continue"
              $VerbosePreference     = "Continue"
            }
            ./update_agent_status.ps1 -Enabled:$false `
                                      -AgentPoolName $(TF_VAR_linux_pipeline_agent_pool) `
                                      -AgentNamePrefix $(TF_VAR_linux_pipeline_agent_name_prefix)-$(TF_WORKSPACE) `
                                      -Token "$(System.AccessToken)"
            ./update_agent_status.ps1 -Enabled:$false `
                                      -AgentPoolName $(TF_VAR_windows_pipeline_agent_pool) `
                                      -AgentNamePrefix $(TF_VAR_windows_pipeline_agent_name_prefix)-$(TF_WORKSPACE) `
                                      -Token "$(System.AccessToken)"
          addSpnToEnvironment: true
          useGlobalConfig: true
          workingDirectory: '$(scriptDirectory)'
        env:
          # Use Pipeline token to access Azure DevOps
          AZURE_DEVOPS_EXT_PAT: '$(System.AccessToken)'

    - task: AzureCLI@2
      displayName: 'Terraform plan & apply (deploy_firewall:$(TF_VAR_deploy_firewall))'
      name: apply
      inputs:
        azureSubscription: '$(subscriptionConnection)'
        scriptType: pscore
        scriptLocation: inlineScript
        inlineScript: |
          ./set_terraform_azurerm_vars.ps1
          ./deploy.ps1 -apply -force
        addSpnToEnvironment: true
        useGlobalConfig: true
        failOnStandardError: true
        retryCountOnTaskFailure: 3
        workingDirectory: '$(scriptDirectory)'

    - ${{ if parameters.deploy }}:
      - task: AzureCLI@2
        displayName: 'Enable Self-Hosted Agent(s)'
        condition: and(eq(variables['TF_VAR_deploy_self_hosted_vms'],'true'),succeeded())
        inputs:
          azureSubscription: '$(subscriptionConnection)'
          scriptType: 'pscore'
          scriptLocation: 'inlineScript'
          inlineScript: |
            if ((${env:system.debug} -eq "true") -or ($env:system_debug -eq "true") -or ($env:SYSTEM_DEBUG -eq "true")) {
              $DebugPreference       = "Continue"
              $InformationPreference = "Continue"
              $VerbosePreference     = "Continue"
            }
            ./update_agent_status.ps1 -Enabled:$true `
                                      -AgentPoolName $(TF_VAR_linux_pipeline_agent_pool) `
                                      -AgentNamePrefix $(TF_VAR_linux_pipeline_agent_name_prefix)-$(TF_WORKSPACE)  `
                                      -Token "$(System.AccessToken)"
            ./update_agent_status.ps1 -Enabled:$true `
                                      -AgentPoolName $(TF_VAR_windows_pipeline_agent_pool) `
                                      -AgentNamePrefix $(TF_VAR_windows_pipeline_agent_name_prefix)-$(TF_WORKSPACE) `
                                      -Token "$(System.AccessToken)"
          addSpnToEnvironment: true
          useGlobalConfig: true
          workingDirectory: '$(scriptDirectory)'
        env:
          # Use Pipeline token to access Azure DevOps
          AZURE_DEVOPS_EXT_PAT: '$(System.AccessToken)'        

    - ${{ if parameters.testReentrance }}:
      - task: AzureCLI@2
        displayName: 'Terraform plan & apply (re-entrance test)'
        inputs:
          azureSubscription: '$(subscriptionConnection)'
          scriptType: pscore
          scriptLocation: inlineScript
          inlineScript: |
            ./set_terraform_azurerm_vars.ps1

            # Swap NAT Gateway <-> Azure Firewall
            # $env:TF_VAR_deploy_firewall = ($env:TF_VAR_deploy_firewall -ieq "true" ? "false" : "true")
            ./deploy.ps1 -apply -force
          addSpnToEnvironment: true
          useGlobalConfig: true
          failOnStandardError: true
          retryCountOnTaskFailure: 3
          workingDirectory: '$(scriptDirectory)'
          
    - ${{ if not(eq(parameters.destroy, 'Never')) }}:
      - pwsh: |
          Write-Host "##vso[task.setvariable variable=result;isOutput=true]success"
        name: provisioningResult
        displayName: 'Indicate provisioning success'
        condition: succeeded()

    - ${{ if not(eq(parameters.destroy, 'Never')) }}:
      - task: TerraformCLI@0
        displayName: 'Terraform destroy (${{ lower(parameters.destroy) }})'
        ${{ if eq(parameters.destroy, 'Always') }}:
          condition: succeededOrFailed()
        ${{ if eq(parameters.destroy, 'On failure') }}:
          condition: failed()
        ${{ if eq(parameters.destroy, 'On success') }}:
          condition: succeeded()
        continueOnError: true # Treat failure as warning during destroy, we will clean up anyway
        inputs:
          command: 'destroy'
          workingDirectory: '$(terraformDirectory)'
          environmentServiceName: '$(subscriptionConnection)'
          runAzLogin: true
          allowTelemetryCollection: true
          retryCountOnTaskFailure: 3

    - ${{ if ne(parameters.destroy, 'Never') }}:
      - task: AzureCLI@2
        name: teardown
        displayName: 'Tear down remaining resources'
        ${{ if eq(parameters.destroy, 'Always') }}:
          condition: or(always(),canceled())
        ${{ if eq(parameters.destroy, 'On failure') }}:
          condition: not(eq(outputs['provisioningResult.result'],'success'))
        ${{ if eq(parameters.destroy, 'On success') }}:
          condition: eq(outputs['provisioningResult.result'],'success')
        inputs:
          azureSubscription: '$(subscriptionConnection)'
          scriptType: pscore
          scriptLocation: inlineScript
          inlineScript: |
            $ErrorActionPreference = "Continue" # Continue to remove resources if remove by resource group fails
            # Build JMESPath expression
            $tagQuery = "[?tags.repository == '$(repository)' && tags.workspace == '$(TF_WORKSPACE)' && tags.runid == '$(Build.BuildId)' && properties.provisioningState != 'Deleting'].id"
            Write-Host "Removing resources identified by `"$tagQuery`"..."

            # Remove resource groups
            $resourceGroupIDs = $(az group list --query "${tagQuery}" -o tsv)
            if ($resourceGroupIDs) {
              Write-Host "Removing resource group(s) `"${resourceGroupIDs}`"..."
              &{ # az writes information to stderr
                $ErrorActionPreference = 'SilentlyContinue'
                az resource delete --ids $resourceGroupIDs 2>&1
              }
            } else {
              Write-Host "No resource groups to remove"
            }

            # Remove (remaining) resources
            $resourceIDs = $(az resource list --query "${tagQuery}" -o tsv)
            if ($resourceIDs) {
              Write-Host "Removing resources `"${resourceIDs}`"..."
              &{ # az writes information to stderr
                $ErrorActionPreference = 'SilentlyContinue'
                az resource delete --ids $resourceIDs 2>&1
              }
            } else {
              Write-Host "No resources to remove"
            }

            # Remove policy definition
            ./delete_policy.ps1 -Workspace $(TF_WORKSPACE)
          addSpnToEnvironment: true
          useGlobalConfig: true
          failOnStandardError: true
          workingDirectory: '$(scriptDirectory)'

    - ${{ if ne(parameters.destroy, 'Never') }}:
      - task: AzureCLI@2
        name: cleanup
        displayName: 'Clean up Terraform state'
        ${{ if eq(parameters.destroy, 'Always') }}:
          condition: or(always(),canceled())
        ${{ if eq(parameters.destroy, 'On failure') }}:
          condition: not(eq(outputs['provisioningResult.result'],'success'))
        ${{ if eq(parameters.destroy, 'On success') }}:
          condition: eq(outputs['provisioningResult.result'],'success')
        inputs:
          azureSubscription: '$(subscriptionConnection)'
          scriptType: pscore
          scriptLocation: inlineScript
          inlineScript: |
            $(scriptDirectory)/set_terraform_azurerm_vars.ps1

            $terraformState = (terraform state pull | ConvertFrom-Json)
            if ($terraformState.resources) {
              Write-Host "Clearing Terraform state in workspace ${env:TF_WORKSPACE}..."
              $terraformState.outputs = New-Object PSObject # Empty output
              $terraformState.resources = @() # No resources
              $terraformState.serial++
              $terraformState | ConvertTo-Json | terraform state push -
            } else {
              Write-Host "No resources in Terraform state in workspace ${env:TF_WORKSPACE}..."
            }
            terraform state pull 
          addSpnToEnvironment: true
          useGlobalConfig: true
          failOnStandardError: true
          workingDirectory: '$(terraformDirectory)'
